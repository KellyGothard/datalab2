# Runnin the MMRR
unfold<-function(X){
x<-vector()
for(i in 2:nrow(X)) x<-c(x,X[i,1:i-1])
return(x)
}
MMRR<-function(Y,X,nperm=999){
#compute regression coefficients and test statistics
nrowsY<-nrow(Y)
y<-unfold(Y)
if(is.null(names(X)))names(X)<-paste("X",1:length(X),sep="")
Xmats<-sapply(X,unfold)
fit<-lm(y~Xmats)
coeffs<-fit$coefficients
summ<-summary(fit)
r.squared<-summ$r.squared
tstat<-summ$coefficients[,"t value"]
Fstat<-summ$fstatistic[1]
tprob<-rep(1,length(tstat))
Fprob<-1
#perform permutations
for(i in 1:nperm){
rand<-sample(1:nrowsY)
Yperm<-Y[rand,rand]
yperm<-unfold(Yperm)
fit<-lm(yperm~Xmats)
summ<-summary(fit)
Fprob<-Fprob+as.numeric(summ$fstatistic[1]>=Fstat)
tprob<-tprob+as.numeric(abs(summ$coefficients[,"t value"])>=abs(tstat))
}
#return values
tp<-tprob/(nperm+1)
Fp<-Fprob/(nperm+1)
names(r.squared)<-"r.squared"
names(coeffs)<-c("Intercept",names(X))
names(tstat)<-paste(c("Intercept",names(X)),"(t)",sep="")
names(tp)<-paste(c("Intercept",names(X)),"(p)",sep="")
names(Fstat)<-"F-statistic"
names(Fp)<-"F p-value"
return(list(r.squared=r.squared,
coefficients=coeffs,
tstatistic=tstat,
tpvalue=tp,
Fstatistic=Fstat,
Fpvalue=Fp))
}
pop_space <- MMRR(X = list(dist, pop.dist), y = list(dist.vars))
pop_space <- MMRR(X = list(dist, pop.dist), Y = list(dist.vars))
# Convert distance objects to matrices
distmat <- as.matrix(dist)
# Convert distance objects to matrices
distmat <- as.matrix(as.numeric(dist), nrow = nrow(dist))
# Convert distance objects to matrices
distmat <- as.matrix(as.numeric(dist), nrow = nrow(as.matrix(dist)))
# Convert distance objects to matrices
distmat <- as.matrix(as.numeric(dist), nrow = nrow(as.matrix(dist)))
# Convert distance objects to matrices
distmat <- as.matrix(as.numeric(dist), nrow = nrow((dist))
# Convert distance objects to matrices
distmat <- as.matrix(as.numeric(dist), nrow = nrow(dist))
# Convert distance objects to matrices
distmat <- as.matrix(as.numeric(dist), nrow = nrow(dist))
nrow(dist)
# Convert distance objects to matrices
distmat <- as.matrix(as.numeric(dist), nrow = nrow(dist.inv))
nrow(dist.inf)
nrow(dist.inv)
# Convert distance objects to matrices
distmat <- matrix(as.numeric(dist), nrow = nrow(dist.inv))
# Convert distance objects to matrices
distmat <- matrix(as.numeric(dist), nrow = nrow(dist))
# Convert distance objects to matrices
distmat <- matrix(as.numeric(dist), nrow = nrow(dist))
# Convert distance objects to matrices
distmat <- matrix(as.numeric(dist), nrow = nrow(as.matrix(dist)))
distmat = as.matrix(dist)
as.numeric(distmat)
# Convert distance objects to matrices
distmat <- as.matrix(distmat)
distmat <- matrix(as.numeric(distmat), nrow = nrow(distmat))
knitr::opts_chunk$set(echo = TRUE, warning = F)
# Load libraries and set working directory
library(tidyverse)
library(ape)
library(ade4)
setwd("C:/users/beasley/dropbox/datalab")
# Read county data
county.raw <- read.table("nyt_population.csv", sep = ",", stringsAsFactors = F,
header = T)
# Retrieve county and state names
cstr <- strsplit(county.raw$county, split = "[,]")
ststr <- strsplit(county.raw$county, split = "[,]")
# Coerce into vector that can be readded to data frame
county.raw$county <- unlist(lapply(cstr, '[[', 1))
county.raw$State <- unlist(lapply(ststr, '[[', 2))
county.raw$State <- sub(".", "", county.raw$State)
# Join county data with state abbreviations
state.abbrev <- read.table("abbr-name.csv", sep = ",", header = F, stringsAsFactors = F)
colnames(state.abbrev) <- c("abbrev", "State")
county.join <- left_join(county.raw, state.abbrev)
# Read in county geocodes and remove duplicates
county.coords <- read.table("GeocodesCounties.csv", sep = ",", stringsAsFactors = F,
header = T)
# Need to only include distinct values for county and state, not latlong
county.coords %>%
group_by(county, state) %>%
select(county, state, latitude, longitude) %>%
distinct(county, state, .keep_all = T) %>%
{. ->> crds}
# Merge geocodes with county data
county <- left_join(county.join, crds, by = c("county", "abbrev"="state"))
# Clean up the dataframe
county$rank <- as.numeric(county$rank)
county <- county[!is.na(county$rank),]
county <- county[!is.na(county$latitude),]
county <- county[!is.na(county$longitude),]
county <- county[!is.na(county$popestimate2018),]
Moran.I(county$income, dist.inv)
# First method for spatial autocorrelation: Moran's I
# Create distance matrix
dist <- dist(county[,13:14], method = 'euclidean')
dist.inv[is.infinite(dist.inv)] <- 0
dist.inv <- 1/as.matrix(dist)
dist.inv[is.infinite(dist.inv)] <- 0
Moran.I(county$income, dist.inv)
pop_space <- MMRR(X = list(distmat, popmat), Y = varmat, nperm = 1)
bits <- anti_join(county.join, county, by = "county")
qplot(bits$abbrev, geom = "bar")
non.bits <- summarise(county, num = n(county$county))
non.bits <- summarise(county$State, num = n())
non.bits <- summarise(county$State, num = count())
non.bits <- summarise(county, num = count(State))
non.bits <- table(county$State)
non.bits
bits <- table(bits$State)
bits
bits[1]
# Remove AK and HI and see what happens
county <- county[-which(county$abbrev == "AK"),]
# Read county data
county.raw <- read.table("nyt_population.csv", sep = ",", stringsAsFactors = F,
header = T)
# Retrieve county and state names
cstr <- strsplit(county.raw$county, split = "[,]")
ststr <- strsplit(county.raw$county, split = "[,]")
# Coerce into vector that can be readded to data frame
county.raw$county <- unlist(lapply(cstr, '[[', 1))
county.raw$State <- unlist(lapply(ststr, '[[', 2))
county.raw$State <- sub(".", "", county.raw$State)
# Join county data with state abbreviations
state.abbrev <- read.table("abbr-name.csv", sep = ",", header = F, stringsAsFactors = F)
colnames(state.abbrev) <- c("abbrev", "State")
county.join <- left_join(county.raw, state.abbrev)
# Read in county geocodes and remove duplicates
county.coords <- read.table("GeocodesCounties.csv", sep = ",", stringsAsFactors = F,
header = T)
# Need to only include distinct values for county and state, not latlong
county.coords %>%
group_by(county, state) %>%
select(county, state, latitude, longitude) %>%
distinct(county, state, .keep_all = T) %>%
{. ->> crds}
# Merge geocodes with county data
county <- left_join(county.join, crds, by = c("county", "abbrev"="state"))
# Clean up the dataframe
county$rank <- as.numeric(county$rank)
county <- county[!is.na(county$rank),]
county <- county[!is.na(county$latitude),]
county <- county[!is.na(county$longitude),]
county <- county[!is.na(county$popestimate2018),]
which(county$abbrev == "AK")
which(county$abbrev == "HI")
# Remove AK and HI and see what happens
county <- county[-which(county$abbrev == "HI"),]
dist2 <- dist(county[,13:14], method = 'euclidean')
dist.inv2[is.infinite(dist.inv2)] <- 0
dist.inv2 <- 1/as.matrix(dist2)
dist.inv2[is.infinite(dist.inv2)] <- 0
Moran.I(county$rank, dist2)
dist2 <- dist(county[,13:14], method = 'euclidean')
dist.inv2 <- 1/as.matrix(dist2)
Moran.I(county$rank, dist.inv2)
sum(is.na(dist.inv2))
sum(is.infinite(dist.inv2))
dist2 <- dist(county[,13:14], method = 'euclidean')
dist.inv2 <- 1/as.matrix(dist2)
dist.inv2[is.infinite(dist.inv2)] <- 0
Moran.I(county$rank, dist.inv2)
knitr::opts_chunk$set(echo = TRUE, warning = F)
# Load libraries and set working directory
library(tidyverse)
library(ape)
library(ade4)
setwd("C:/users/beasley/dropbox/datalab")
# Read county data
county.raw <- read.table("nyt_population.csv", sep = ",", stringsAsFactors = F,
header = T)
# Retrieve county and state names
cstr <- strsplit(county.raw$county, split = "[,]")
ststr <- strsplit(county.raw$county, split = "[,]")
# Coerce into vector that can be readded to data frame
county.raw$county <- unlist(lapply(cstr, '[[', 1))
county.raw$State <- unlist(lapply(ststr, '[[', 2))
county.raw$State <- sub(".", "", county.raw$State)
# Join county data with state abbreviations
state.abbrev <- read.table("abbr-name.csv", sep = ",", header = F, stringsAsFactors = F)
colnames(state.abbrev) <- c("abbrev", "State")
county.join <- left_join(county.raw, state.abbrev)
# Read in county geocodes and remove duplicates
county.coords <- read.table("GeocodesCounties.csv", sep = ",", stringsAsFactors = F,
header = T)
# Need to only include distinct values for county and state, not latlong
county.coords %>%
group_by(county, state) %>%
select(county, state, latitude, longitude) %>%
distinct(county, state, .keep_all = T) %>%
{. ->> crds}
# Merge geocodes with county data
county <- left_join(county.join, crds, by = c("county", "abbrev"="state"))
# Clean up the dataframe
county$rank <- as.numeric(county$rank)
county <- county[!is.na(county$rank),]
county <- county[!is.na(county$latitude),]
county <- county[!is.na(county$longitude),]
county <- county[!is.na(county$popestimate2018),]
# First method for spatial autocorrelation: Moran's I
# Create distance matrix
dist <- dist(county[,13:14], method = 'euclidean')
dist.inv <- 1/as.matrix(dist)
dist.inv[is.infinite(dist.inv)] <- 0
# Calculate Moran's I
Moran.I(county$rank, dist.inv)
Moran.I(county$income, dist.inv)
# Look at variation within bottom 10%: does the map capture variability?
lowest.rank <- top_n(county$rank, n = -0.1*nrow(county$rank))
# Look at variation within bottom 10%: does the map capture variability?
lowest.rank <- subset(county, county$rank < quantile(county$rank, prob = 0.1, na.rm = TRUE))
quantile(county$rank, prob = 0.1, na.rm = TRUE)
# Look at variation within bottom 10%: does the map capture variability?
lowest.rank <- subset(county, county$rank > quantile(county$rank, prob = 0.9, na.rm = TRUE))
quantile(county$rank, prob = 0.9, na.rm = TRUE)
county$rank > quantile(county$rank, prob = 0.9, na.rm = TRUE)
# Look at variation within bottom 10%: does the map capture variability?
lowest.rank <- subset(county, which(county$rank > quantile(county$rank, prob = 0.9, na.rm = TRUE)))
# Look at variation within bottom 10%: does the map capture variability?
lowest.rank <- subset(county, rank > quantile(rank, prob = 0.9, na.rm = TRUE))
lowest.income <- subset(county, income < quantile(income, prob = 0.1, na.rm = T))
hist(lowest.income)
hist(lowest.income$income)
hist(lowest.rank$rank)
hist(lowest.rank$income)
hist(lowest.rank$rank)
hist(lowest.rank$rank)
hist(lowest.rank$income)
hist(county$income)
ggplot(data = county, aes (x = rank))+
geom_density()
ggplot(data = county, aes (x = rank))+
geom_density()
# Look at variation within rank classes vs. income classes
ggplot(data = county, aes (x = rank))+
geom_density()
# Look at variation within rank classes vs. income classes
ggplot(data = county, aes (x = rank))+
geom_density()
# Look at variation within rank classes vs. income classes
ggplot(data = county, aes (x = rank))+
geom_density()+
theme_classic(base_size = 20)
# Look at variation within rank classes vs. income classes
ggplot(data = county, aes (x = rank))+
geom_density()+
labs(x = "Rank", y = "Density")+
theme_classic(base_size = 20)+
theme(axis.text.y = element_blank())
# Look at variation within rank classes vs. income classes
ggplot(data = county, aes (x = rank))+
geom_density(size = 2)+
labs(x = "Rank", y = "Density")+
theme_classic(base_size = 20)+
theme(axis.text.y = element_blank())
# Look at variation within rank classes vs. income classes
ggplot(data = county, aes (x = rank))+
geom_density(size = 1.5)+
labs(x = "Rank", y = "Density")+
theme_classic(base_size = 20)+
theme(axis.text.y = element_blank())
# Look at variation within rank classes vs. income classes
rank.quantiles <- quantile(county$rank, c(0.1, 0.9))
ggplot(data = county, aes (x = rank))+
geom_density(fill = rank.quantiles)+
labs(x = "Rank", y = "Density")+
theme_classic(base_size = 20)+
theme(axis.text.y = element_blank())
# Look at variation within rank classes vs. income classes
rank.density <- density(county$rank)
rank.frame <- data.frame(x = rank.density$x, y = rank.density$y)
rank.quantiles <- quantile(county$rank, c(0.1, 0.9))
rank.frame$quant <- factor(findInterval(rank.frame$x, rank.quantiles))
ggplot(data = rank.frame, aes (x, y))+
geom_line()+
geom_ribbon(aes(ymin=0, ymax=y, fill=quant))
ggplot(data = rank.frame, aes (x, y))+
geom_line()+
geom_ribbon(aes(ymin=0, ymax=y, fill=quant))+
scale_fill_discrete(breaks = quantiles, values = c("blue", "white", "red"))
ggplot(data = rank.frame, aes (x, y))+
geom_line()+
geom_ribbon(aes(ymin=0, ymax=y, fill=quant))+
scale_fill_manual(breaks = quantiles, values = c("blue", "white", "red"))
ggplot(data = rank.frame, aes (x, y))+
geom_line()+
geom_ribbon(aes(ymin=0, ymax=y, fill=quant))+
scale_fill_manual(breaks = rank.frame$quantiles, values = c("blue", "white", "red"))
ggplot(data = rank.frame, aes (x, y))+
geom_line()+
geom_ribbon(aes(ymin=0, ymax=y, fill=quant))+
scale_fill_manual(breaks = rank.frame$quantiles, values = c("deepskyblue", "white", "darkorange2"))
ggplot(data = rank.frame, aes (x, y))+
geom_line()+
geom_ribbon(aes(ymin=0, ymax=y, fill=quant))+
scale_fill_manual(breaks = rank.frame$quantiles, values = c("deepskyblue4", "white", "darkorange2"))
ggplot(data = rank.frame, aes (x, y))+
geom_line()+
geom_ribbon(aes(ymin=0, ymax=y, fill=quant))+
scale_fill_manual(breaks = rank.frame$quantiles,
values = c("deepskyblue4", "white", "darkorange2"))+
labs(x = "Rank", y = "Density")+
theme_classic(base_size = 20)+
theme(axis.text.y = element_blank())
ggplot(data = rank.frame, aes (x, y))+
geom_line(size = 2)+
geom_ribbon(aes(ymin=0, ymax=y, fill=quant))+
scale_fill_manual(breaks = rank.frame$quantiles,
values = c("deepskyblue4", "white", "darkorange2"))+
labs(x = "Rank", y = "Density")+
theme_classic(base_size = 20)+
theme(axis.text.y = element_blank())
ggplot(data = income.frame, aes (x, y))+
geom_line(size = 2)+
geom_ribbon(aes(ymin=0, ymax=y, fill=quant))+
scale_fill_manual(breaks = income.frame$quantiles,
values = c("darkorange2", "white", "deepskyblue4"))+
labs(x = "Rank", y = "Density")+
theme_classic(base_size = 20)+
theme(axis.text.y = element_blank())
income.frame <- data.frame(x = income.density$x, y = income.density$y)
income.density <- density(county$income)
income.frame <- data.frame(x = income.density$x, y = income.density$y)
income.quantiles <- quantile(county$income, c(0.1, 0.9))
income.frame$quant <- factor(findInterval(income.frame$x, income.quantiles))
ggplot(data = income.frame, aes (x, y))+
geom_line(size = 2)+
geom_ribbon(aes(ymin=0, ymax=y, fill=quant))+
scale_fill_manual(breaks = income.frame$quantiles,
values = c("darkorange2", "white", "deepskyblue4"))+
labs(x = "Rank", y = "Density")+
theme_classic(base_size = 20)+
theme(axis.text.y = element_blank())
knitr::opts_chunk$set(echo = TRUE, warning = F)
# Load libraries and set working directory
library(tidyverse)
library(ape)
library(ade4)
setwd("")
# Look at variation within rank classes vs. income classes
rank.density <- density(county$rank)
rank.frame <- data.frame(x = rank.density$x, y = rank.density$y)
rank.quantiles <- quantile(county$rank, c(0.1, 0.9))
rank.frame$quant <- factor(findInterval(rank.frame$x, rank.quantiles))
ggplot(data = rank.frame, aes (x, y))+
geom_line(size = 2)+
geom_ribbon(aes(ymin=0, ymax=y, fill=quant))+
scale_fill_manual(breaks = rank.frame$quantiles,
values = c("deepskyblue4", "white", "darkorange2"))+
labs(x = "Rank", y = "Density")+
theme_classic(base_size = 20)+
theme(axis.text.y = element_blank())
# Do the same thing for income
income.density <- density(county$income)
income.density <- density(county$income)
income.frame <- data.frame(x = income.density$x, y = income.density$y)
income.quantiles <- quantile(county$income, c(0.1, 0.9))
income.frame$quant <- factor(findInterval(income.frame$x, income.quantiles))
ggplot(data = income.frame, aes (x, y))+
geom_line(size = 2)+
geom_ribbon(aes(ymin=0, ymax=y, fill=quant))+
scale_fill_manual(breaks = income.frame$quantiles,
values = c("darkorange2", "white", "deepskyblue4"))+
labs(x = "Rank", y = "Density")+
theme_classic(base_size = 20)+
theme(axis.text.y = element_blank())
# Look at variation within rank classes vs. income classes
rank.density <- density(county$rank)
rank.frame <- data.frame(x = rank.density$x, y = rank.density$y)
rank.quantiles <- quantile(county$rank, c(0.1, 0.9))
rank.frame$quant <- factor(findInterval(rank.frame$x, rank.quantiles))
ggplot(data = rank.frame, aes (x, y))+
geom_line(size = 2)+
geom_ribbon(aes(ymin=0, ymax=y, fill=quant))+
scale_fill_manual(breaks = rank.frame$quantiles,
values = c("deepskyblue4", "white", "darkorange2"))+
labs(x = "Rank", y = "Density")+
theme_classic(base_size = 20)+
theme(axis.text.y = element_blank())
# Do the same thing for income
income.density <- density(county$income)
income.density <- density(county$income)
income.frame <- data.frame(x = income.density$x, y = income.density$y)
income.quantiles <- quantile(county$income, c(0.1, 0.9))
income.frame$quant <- factor(findInterval(income.frame$x, income.quantiles))
ggplot(data = income.frame, aes (x, y))+
geom_line(size = 2)+
geom_ribbon(aes(ymin=0, ymax=y, fill=quant))+
scale_fill_manual(breaks = income.frame$quantiles,
values = c("darkorange2", "white", "deepskyblue4"))+
labs(x = "Income", y = "Density")+
theme_classic(base_size = 20)+
theme(axis.text.y = element_blank())
ggplot(data = rank.frame, aes (x, y))+
geom_line(size = 2)+
geom_ribbon(aes(ymin=0, ymax=y, fill=quant))+
scale_fill_manual(breaks = rank.frame$quantiles,
values = c("deepskyblue4", "white", "darkorange2"))+
labs(x = "Rank", y = "Density")+
theme_classic(base_size = 20)+
theme(axis.text.y = element_blank())
ggplot(data = income.frame, aes (x, y))+
geom_line(size = 2)+
geom_ribbon(aes(ymin=0, ymax=y, fill=quant))+
scale_fill_manual(breaks = income.frame$quantiles,
values = c("darkorange2", "white", "deepskyblue4"))+
labs(x = "Income", y = "Density")+
theme_classic(base_size = 20)+
theme(axis.text.y = element_blank())
citation("MASS")
setwd("c:/users/beasley/documents/datalab2")
# Load data -----------------------------------------
inits <- read.table("\smac\triggernaclean.csv", sep = ",", header = T, stringsAsfactors = F)
# Load data -----------------------------------------
inits <- read.table("~\smac\triggernaclean.csv", sep = ",", header = T, stringsAsfactors = F)
# Load data -----------------------------------------
inits <- read.table("smac\triggernaclean.csv", sep = ",", header = T, stringsAsfactors = F)
# Load data -----------------------------------------
inits <- read.table("smac\triggernaclean.csv", sep = ",", header = T, stringsAsFactors = F)
# Load data -----------------------------------------
inits <- read.table("smac\triggernaclean.csv", sep = ",", header = T, stringsAsFactors = F)
# Load data -----------------------------------------
inits <- read.table("smac/triggernaclean.csv", sep = ",", header = T, stringsAsFactors = F)
followup <- read.table("smac/followupclean.csv", sep = ",", header = T,
stringsAsFactors = F)
# Select columns with disease data --------------------------------
inits %>%
select(Trig_date, District, Chiefdom, Male_child:Total_female, ss_mc:cb_fa)
# Load req'd packages --------------------------------
library(tidyverse)
# Select columns with disease data --------------------------------
inits %>%
select(Trig_date, District, Chiefdom, Male_child:Total_female, ss_mc:cb_fa)
# Select columns with disease data --------------------------------
inits %>%
select(Trig_date, District, Chiefdom, Male_child:Total_female, ss_mc:cb_fa) %>%
{. - >> smol.inits}
# Select columns with disease data --------------------------------
inits %>%
select(Trig_date, District, Chiefdom, Male_child:Total_female, ss_mc:cb_fa) %>%
{. ->> smol.inits}
# Select columns with disease data --------------------------------
inits %>%
select(Trig_date, District, Chiefdom, Male_child:Total_female, ss_mc:cb_fa) %>%
mutate(Total_all = Total_male+Total_female)%>%
{. ->> smol.inits}
smol.inits$Total_all
# Select columns with disease data --------------------------------
inits %>%
select(Trig_date, District, Chiefdom, Male_child:Total_female, ss_mc:cb_fa) %>%
mutate(Total_all = Total_male+Total_female) %>%
mutate(Sick_all = ss_mc+ss_fc+ss_ma+ss_fa) %>%
{. ->> smol.inits}
# Select columns with disease data --------------------------------
inits %>%
select(Trig_date, District, Chiefdom, Male_child:Total_female, ss_mc:cb_fa) %>%
mutate(Total_all = Total_male+Total_female) %>%
mutate(Sick_all = ss_mc+ss_fc+ss_ma+ss_fa) %>%
mutate(Deaths_all = d_mc+d_fc+d_ma+d_fa) %>%
select(Trig_date, District, Chiefdom, Total_all, Sick_all, Deaths_all) %>%
{. ->> smol.inits}
# Select columns with disease data --------------------------------
inits %>%
select(Trig_date, District, Chiefdom, Male_child:Total_female, ss_mc:cb_fa) %>%
mutate(Total_all = Total_male+Total_female) %>%
mutate(Sick_all = ss_mc+ss_fc+ss_ma+ss_fa) %>%
mutate(Deaths_all = d_mc+d_fc+d_ma+d_fa) %>%
select(Trig_date, District, Chiefdom, Total_all, Sick_all, Deaths_all) %>%
group_by(District, Chiefdom) %>%
{. ->> smol.inits}
summarise(smol.inits)
smol.inits[1,]
summarise(smol.inits, sick = sum(Sick_all))
summarise(smol.inits, Population = Total_all, Sick = sum(Sick_all), Deaths = sum(Deaths_all))
summarise(smol.inits, Population = sum(Total_all), Sick = sum(Sick_all), Deaths = sum(Deaths_all))
# Select columns with disease data --------------------------------
inits %>%
select(Trig_date, District, Chiefdom, Male_child:Total_female, ss_mc:cb_fa) %>%
mutate(Total_all = Total_male+Total_female) %>%
mutate(Sick_all = ss_mc+ss_fc+ss_ma+ss_fa) %>%
mutate(Deaths_all = d_mc+d_fc+d_ma+d_fa) %>%
select(Trig_date, District, Chiefdom, Total_all, Sick_all, Deaths_all) %>%
group_by(District, Chiefdom) %>%
summarise(smol.inits, Population = sum(Total_all), Sick = sum(Sick_all),
Deaths = sum(Deaths_all)) %>%
{. ->> smol.inits}
